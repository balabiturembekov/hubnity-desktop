# Критические исправления и корневые причины

Документ описывает, что было реализовано неправильно и как это исправлено.

---

## 1. Синхронизация не работала («Синхронизировано: 0»)

### В чём была ошибка

- **Токены в Rust** хранятся в `AuthManager` и задаются только вызовом команды `set_auth_tokens` из фронта.
- **Фоновая синхронизация** в Rust запускается в отдельном потоке раз в 60 с и вызывает `auth_manager.get_access_token()`. Если токен не был передан — sync **молча пропускает** тик и возвращает 0.
- **Фронт** вызывал `set_auth_tokens` только при монтировании (в `restoreTokens`) и при логине. Из‑за порядка загрузки (Zustand persist, порядок эффектов) токен мог не успеть попасть в Rust до первого тика sync или вообще не вызываться в нужный момент.

Итог: Rust часто не видел токен → sync всегда пропускался → «Синхронизировано» оставалось 0.

### Что сделано

- **Периодическая передача токенов и запуск sync с фронта:** при залогиненном пользователе каждые 30 с вызываются `set_auth_tokens` (текущий токен из api/localStorage) и `sync_queue_now`. Синхронизацию ведёт фронт, а не только фоновый поток в Rust.
- **Повторный restore при старте:** `restoreTokens()` вызывается при монтировании и ещё раз через 2 с (на случай, если localStorage/регидрация не успели).
- **В Настройках** при нажатии «Обновить» перед запросом статистики вызываются `set_auth_tokens` и `sync_queue_now`.

---

## 2. Скриншоты не появлялись в UI

### В чём была ошибка

- Загрузка шла через Rust: скриншот **сначала попадал в очередь**, а на сервер уходил только при следующем sync (до 60 с).
- Фронт по событию `screenshot:uploaded` один раз через 1 с вызывал `getScreenshots` — к этому моменту сервер часто ещё не имел скриншота.

### Что сделано

- После постановки скриншота в очередь в Rust сразу вызывается `sync_queue(5)` (в `upload_screenshot`), чтобы задача ушла на сервер в течение нескольких секунд.
- На фронте после `screenshot:uploaded` делается несколько запросов списка скриншотов с задержками (500 мс, 2 с, 5 с, 12 с) и при появлении данных блок «Скриншоты» раскрывается.

---

## 3. Скриншоты при паузе из‑за неактивности

### В чём была ошибка

- Решение о паузе и вызов API выполнялись асинхронно, а в сторе `isPaused` / `idlePauseStartTime` обновлялись после ответа.
- Таймер скриншота мог сработать в этот промежуток и считать, что таймер ещё не на паузе.

### Что сделано

- При срабатывании автопаузы из‑за неактивности **сразу** в сторе выставляются `isPaused: true` и `idlePauseStartTime` (до вызова API).
- При срабатывании таймера скриншота сначала проверяется состояние; если пауза или idle — скриншот не делается и следующий не планируется.

---

## 4. Спам в логах от idle-окна

### В чём была ошибка

- Idle-окно многократно запрашивало состояние (0, 100, 500, 1000, 2000 мс и каждые 2 с), каждое обращение логировалось в Rust через `println!`.

### Что сделано

- Сокращено число запросов при открытии (0, 500, 1500 мс), далее опрос раз в 10 с.
- Логи `update_idle_state` и `request_idle_state` переведены на `tracing::debug!`, чтобы по умолчанию не засорять консоль.

---

## Что проверять после изменений

1. **Синхронизация:** залогиниться, сделать действия (старт/пауза/скриншот), открыть Настройки → Синхронизация. Через 30–60 с «Синхронизировано» должно расти; при нажатии «Обновить» — обновиться сразу.
2. **Скриншоты в UI:** запустить таймер, дождаться скриншота, открыть блок «Скриншоты» — через несколько секунд новый скриншот должен появиться.
3. **Пауза по неактивности:** включить автопаузу (например 2 мин), не трогать приложение 2+ минут — скриншоты не должны делаться в момент паузы и после неё до возобновления.

---

## Запуск для отладки

- Приложение нужно запускать через **`pnpm tauri dev`** из корня проекта (не только `cargo run` из `src-tauri`), иначе фронт не подгружается и окно пустое.
- Логи синхронизации и токенов: в терминале искать `[SYNC]`, `[AUTH]`. При необходимости: `RUST_LOG=hubnity=debug pnpm tauri dev`.
