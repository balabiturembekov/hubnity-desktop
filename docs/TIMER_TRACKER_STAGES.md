# Этапы работы тайм-трекера Hubnity

Документ задаёт, **как должен работать** тайм-трекер, и разбивает проверку/доработку на этапы. Задачи выполняются **поэтапно**: сначала этап 1, затем 2 и т.д.

---

## Модель работы (держать в уме)

- **Источник истины по времени:** Rust `TimerEngine` (состояние FSM: Stopped / Running / Paused, `accumulated_seconds`, `day_start`).
- **Персистентность:** состояние сохраняется в SQLite при pause/stop, при закрытии окна и раз в 30 с.
- **Сервер:** активная запись (time entry) — RUNNING/PAUSED/STOPPED; синхронизация через API и очередь (offline-first).
- **UI:** отображает состояние движка (опрос `get_timer_state` раз в 1 с) и вызывает команды через store (start/pause/resume/stop).

---

## Этап 1: Запуск приложения и восстановление состояния

**Цель:** после открытия приложения таймер и активная запись восстанавливаются предсказуемо.

- [x] **1.1** Backend при старте загружает состояние из БД (`restore_state`), смена дня учитывается (локальная дата).
- [x] **1.2** Frontend при монтировании (если пользователь авторизован) вызывает `loadActiveTimeEntry()` и синхронизирует store и движок с сервером (RUNNING → start/resume, PAUSED → pause).
- [x] **1.3** В store `isTracking`/`isPaused` выставляются только если движок реально в нужном состоянии (проверка после start/resume в `loadActiveTimeEntry` и `startTracking`).
- [x] **1.4** При logout backend сбрасывает таймер (`reset_state` в `set_auth_tokens` при пустом user_id).

**Критерий этапа:** открыл приложение — вижу корректное состояние (остановлен / на паузе / идёт); после выхода и входа другого пользователя старый таймер не виден.

---

## Этап 2: Старт / стоп / пауза / возобновление (основной сценарий)

**Цель:** кнопки Старт, Стоп, Пауза, Возобновить работают и не оставляют движок и UI в противоречии.

- [x] **2.1** **Старт:** выбор проекта → `startTracking` → API создаёт time entry (или восстанавливает активный) → движок `start()`/`resume()` → проверка, что движок RUNNING → обновление store.
- [x] **2.2** При ошибке авторизации (401/403) при Старте — сообщение «Сессия истекла», переход на экран входа (auth:logout).
- [x] **2.3** **Пауза:** движок `pause()` вызывается первым, затем API `pauseTimeEntry`; при ошибке API движок уже на паузе — UI согласован.
- [x] **2.4** **Возобновление:** API `resumeTimeEntry` → движок `resume()` → обновление store; при ошибке API — ошибка в UI, движок не трогаем (остаётся Paused).
- [x] **2.5** **Стоп:** API `stopTimeEntry` → движок `stop()` → очистка store; при ошибке API — всё равно останавливаем движок и сбрасываем UI, чтобы не было «ошибка, но таймер идёт».

**Критерий этапа:** все переходы Stopped ↔ Running ↔ Paused работают; при сетевой/авторизационной ошибке UI и движок не расходятся.

---

## Этап 3: Синхронизация с сервером и смена дня

**Цель:** мультиустройство и смена календарного дня обрабатываются корректно.

- [x] **3.1** Периодическая синхронизация (например, раз в 10 с): если на сервере активная запись RUNNING, а локально не RUNNING — запуск; если на сервере PAUSED/STOPPED, а локально RUNNING — пауза/стоп.
- [x] **3.2** Первый запуск синка после открытия приложения — с задержкой (например, 30 с), чтобы не гасить только что восстановленный таймер.
- [x] **3.3** Смена дня: и на фронте, и в Rust используется **локальная дата**; при смене дня вызывается `reset_day` (обнуление накопленного за день, обновление `day_start`).

**Критерий этапа:** смена дня в полночь по местному времени не ломает таймер; синхронизация не «дергает» только что восстановленный старт.

---

## Этап 4: Idle (простой) и окно простоя

**Цель:** при простое таймер ставится на паузу, показывается окно; пользователь может продолжить или остановить.

- [x] **4.1** Детекция простоя (по активности) → пауза движка и API (`pauseTracking(isIdlePause: true)`), показ idle-окна. При ошибке паузы сбрасываем `idlePauseStartTime` в сторе.
- [x] **4.2** Кнопки в idle-окне: «Продолжить» → событие `resume-tracking` → `resumeTracking()`; «Стоп» → событие `stop-tracking` → `stopTracking()`.
- [x] **4.3** После возобновления/остановки idle-окно скрывается, `idlePauseStartTime` сбрасывается.

**Критерий этапа:** при простое таймер ставится на паузу, окно показывается; выбор «Продолжить»/«Стоп» отрабатывает без рассинхрона.

---

## Этап 5: Закрытие приложения и сон системы

**Цель:** при закрытии окна или уходе системы в сон состояние не теряется.

- [x] **5.1** При закрытии окна (событие `tauri://close-requested`) вызывается `save_state()` движка.
- [x] **5.2** Периодическое сохранение (например, раз в 30 с) как подстраховка при force quit.
- [x] **5.3** При пробуждении системы: в `get_state()` при обнаружении большого пропуска времени (time gap) вызывается `handle_system_sleep()` → пауза движка и сохранение; при старте приложения вызывается `handle_system_wake()` (сохранение в БД).

**Критерий этапа:** закрыл приложение с запущенным таймером — после следующего открытия состояние восстанавливается (этап 1); сон/пробуждение не портят накопленное время.

---

## Этап 6: Очередь синхронизации и офлайн

**Цель:** при отсутствии сети операции ставятся в очередь и выполняются при появлении связи.

- [x] **6.1** Start/Pause/Resume/Stop при наличии токена кладутся в очередь (`enqueue_time_entry`), при возможности вызывается API.
- [x] **6.2** Фоновая синхронизация очереди: поток в lib.rs раз в 60 с вызывает `sync_queue(5)`; фронт раз в 30 с вызывает `sync_queue_now`.
- [x] **6.3** При смене пользователя в `set_auth_tokens` вызывается `clear_user_data()` (очередь и таймер сбрасываются — этап 1).

**Критерий этапа:** офлайн-действия не теряются; после появления сети данные уходят на сервер.

---

## Порядок выполнения задач

1. Выполнять этапы **по номерам** (1 → 2 → 3 → 4 → 5 → 6).
2. В рамках этапа — выполнять пункты по порядку (1.1, 1.2, …).
3. После каждого этапа — прогонять тесты и при необходимости ручную проверку.
4. При поиске багов — сверяться с этим документом: к какому этапу относится сценарий и что должно быть по контракту.

Файл можно использовать как чеклист: отмечать пункты по мере реализации/проверки.
