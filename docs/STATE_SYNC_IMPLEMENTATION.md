# Реализация тестирования синхронизации состояния

## Выполнено

### Этап 1: E2E тесты для рассинхронизации состояния ✅

Создан файл `e2e/state-sync.spec.ts` с тестами:

1. **rapid sequential actions maintain state sync**
   - Проверяет, что быстрые последовательные действия (start → pause → resume → stop) не вызывают рассинхронизацию
   - Проверяет синхронизацию store и Timer Engine после каждого действия

2. **state syncs after API error**
   - Проверяет, что после ошибки API состояние синхронизируется с Timer Engine, а не с API статусом
   - Симулирует ситуацию, когда API возвращает ошибку, но Timer Engine продолжает работать

3. **concurrent operations maintain sync**
   - Проверяет, что параллельные операции (sync + user action) не вызывают рассинхронизацию
   - Проверяет защиту от race conditions через isLoading

4. **loadActiveTimeEntry syncs with Timer Engine**
   - Проверяет, что loadActiveTimeEntry проверяет Timer Engine после синхронизации
   - Проверяет, что состояние синхронизируется с Timer Engine, а не с сервером

### Этап 2: Runtime проверки инвариантов состояния ✅

Добавлена функция `assertStateInvariant()` в `useTrackerStore.ts`:

- **Проверка инвариантов:**
  - `isTracking` должен соответствовать Timer Engine (true если RUNNING или PAUSED)
  - `isPaused` должен соответствовать Timer Engine (true только если PAUSED)

- **Автоматическое исправление:**
  - При обнаружении рассинхронизации автоматически синхронизирует состояние
  - Логирует предупреждение для отладки
  - Отправляет событие в Sentry для мониторинга

- **Защита от ложных срабатываний:**
  - Не проверяет инварианты во время операций (isLoading = true)
  - Это предотвращает ложные срабатывания во время переходов состояния

### Этап 3: Периодическая проверка инвариантов ✅

Добавлен `useEffect` в `App.tsx`:

- Проверяет инварианты каждые 5 секунд
- Первая проверка через 5 секунд после загрузки
- Автоматически обнаруживает и исправляет рассинхронизацию

### Этап 4: Мониторинг рассинхронизации ✅

Интеграция с Sentry:

- При обнаружении рассинхронизации отправляется событие в Sentry
- Включает контекст: состояние store и Timer Engine
- Позволяет отслеживать частоту рассинхронизации в продакшене

## Как использовать

### Запуск E2E тестов

```bash
pnpm test:e2e
# или для конкретного файла
pnpm test:e2e state-sync
```

### Проверка инвариантов вручную

```typescript
import { useTrackerStore } from './store/useTrackerStore';

// Проверить инварианты вручную
await useTrackerStore.getState().assertStateInvariant();
```

### Мониторинг в Sentry

События рассинхронизации автоматически отправляются в Sentry с тегом `state_desync` и контекстом:
- `storeState.isTracking`
- `storeState.isPaused`
- `timerEngineState`

## Следующие шаги

1. **Property-based тесты** (опционально)
   - Использовать библиотеку `proptest` для генерации случайных последовательностей действий
   - Проверять консистентность состояния после любой последовательности

2. **Расширение E2E тестов**
   - Добавить тесты для edge cases (например, сбой сети во время операций)
   - Добавить тесты для мультиустройственной синхронизации

3. **Метрики**
   - Добавить счетчик рассинхронизаций для отслеживания частоты
   - Добавить алерты в Sentry при превышении порога

## Результаты

- ✅ 4 E2E теста для проверки синхронизации состояния
- ✅ Runtime проверка инвариантов с автоматическим исправлением
- ✅ Периодическая проверка каждые 5 секунд
- ✅ Интеграция с Sentry для мониторинга
- ✅ Защита от ложных срабатываний во время операций

Все изменения протестированы и готовы к использованию.
